//! EXAMPLE ONLY: DO NOT USE IN PRODUCTION!
#![allow(unused)]

use std::cell::UnsafeCell;
use std::ffi::c_void;
use std::fmt::Write;
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Mutex;

use josekit::jws;
use mariadb::log::{debug, error, info};
use mariadb::plugin::encryption::{Encryption, KeyError, KeyManager};
use mariadb::plugin::{
    register_plugin, Init, InitError, License, Maturity, PluginType, SysVarConstString, SysVarOpt,
};
use mariadb::service_sql::{ClientError, Connection, Rows};

const KEY_TABLE: &str = "mysql.clevis_keys";
/// Max length a key can be, used for table size and buffer checking
const KEY_MAX_BYTES: usize = 16;

/// String system variable to set server address
static TANG_SERVER: SysVarConstString = SysVarConstString::new();

register_plugin! {
    KeyMgtClevis,
    ptype: PluginType::MariaEncryption,
    name: "clevis_key_management",
    author: "Daniel Black & Trevor Gross",
    description: "Clevis key management plugin",
    license: License::Gpl,
    maturity: Maturity::Experimental,
    version: "0.1",
    init: KeyMgtClevis,
    encryption: false,
    variables: [
        SysVar {
            ident: TANG_SERVER,
            vtype: SysVarConstString,
            name: "tang_server",
            description: "the tang server to use for key exchange",
            options: [SysVarOpt::OptionalCliArg],
            default: "localhost"
        }
    ]
}

struct KeyMgtClevis;

fn make_new_key(conn: &Connection) -> Result<String, ClientError> {
    let server = TANG_SERVER.get();
    format!(
        "INSERT IGNORE INTO {KEY_TABLE} 
        SET key_server = {server}
        RETURNING jws"
    );

    // get the jws value
    let jws: &str;

    todo!()
}

impl Init for KeyMgtClevis {
    /// Create needed tables
    fn init() -> Result<(), InitError> {
        let mut conn = Connection::connect_local().map_err(|e| {
            error!("error with local connection: {e}");
            InitError
        })?;

        conn.execute(&format!(
            "CREATE TABLE IF NOT EXISTS {KEY_TABLE} (
                key_id INT UNSIGNED NOT NULL COMMENT 'MariaDB key_id',
                key_version INT UNSIGNED NOT NULL COMMENT 'MariaDB key_version',
                server VARBINARY(64) NOT NULL COMMENT 'Tang server that sourced this key',
                client_pub TINYTEXT NOT NULL COMMENT 'Public key generated by the client',
                PRIMARY KEY (key_id, key_version)
            ) ENGINE=InnoDB"
        ))
        .map_err(|e| {
            error!("error creating table {KEY_TABLE}: {e}");
            InitError
        })?;

        let mut rows = conn
            .query(&format!("SELECT * FROM {KEY_TABLE}"))
            .map_err(|e| {
                error!("error selecting {KEY_TABLE}: {e}");
                InitError
            })?;

        for row in rows {
            dbg!(row);
        }

        Ok(())
    }
}

/// Execute a query, printing an error and returning KeyError if needed. No result
fn key_execute(conn: &mut Connection, q: &str, key_id: u32) -> Result<u64, KeyError> {
    conn.execute(q).map_err(|e| {
        error!("execute key_id: {key_id}: SQL error: {e}. Query:\n{q}");
        KeyError::Other
    })
}

/// Execute a query, printing an error, return the result
fn key_query<'a>(conn: &'a mut Connection, q: &str, key_id: u32) -> Result<Rows<'a>, KeyError> {
    conn.query(q).map_err(|e| {
        error!("query key_id {key_id}: SQL error: {e}. Query:\n{q}");
        KeyError::Other
    })
}

impl KeyManager for KeyMgtClevis {
    fn get_latest_key_version(key_id: u32) -> Result<u32, KeyError> {
        let mut conn = Connection::connect_local().map_err(|_| KeyError::Other)?;
        let mut q = format!(
            "SELECT key_version FROM {KEY_TABLE}
            WHERE key_id = {key_id}
            ORDER BY key_version DESC
            LIMIT 1"
        );
        let mut rows = key_query(&mut conn, &q, key_id)?;
        for row in rows {
            dbg!(row);
        }

        // // directly push format string
        // // no key rotation yet so all key versions are 1 for now
        // let key_version: u32 = 1;
        // write!(q, "AND key_version = {key_version} FOR UPDATE");

        // run_execute(&mut conn, "START TRANSACTION", key_id)?;
        // run_query(&mut conn, &q, key_id)?;

        // let Ok(new_key) = make_new_key(&conn) else {
        //     run_execute(&mut conn, "ROLLBACK", key_id)?;
        //     todo!();
        // };

        // let q = format!(
        //     r#"INSERT INTO {KEY_TABLE} VALUES (
        //     {key_id}, {key_version}, "{server_name}", {new_key} )"#,
        //     server_name = TANG_SERVER.get()
        // );
        // run_execute(&mut conn, &q, key_id)?;

        todo!()
    }

    fn get_key(key_id: u32, key_version: u32, dst: &mut [u8]) -> Result<(), KeyError> {
        let mut conn = Connection::connect_local().map_err(|_| KeyError::Other)?;
        let q = format!(
            "SELECT key FROM {KEY_TABLE} WHERE key_id = {key_id} AND key_version = {key_version}"
        );
        conn.query(&q).map_err(|_| KeyError::Other)?;
        // TODO: generate key with server
        let key: &[u8];
        todo!();
        dst[..key.len()].copy_from_slice(key);
        Ok(())
    }

    fn key_length(_key_id: u32, _key_version: u32) -> Result<usize, KeyError> {
        Ok(KEY_MAX_BYTES)
    }
}
