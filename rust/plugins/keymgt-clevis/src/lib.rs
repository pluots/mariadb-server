//! EXAMPLE ONLY: DO NOT USE IN PRODUCTION!
#![allow(unused)]

use std::cell::UnsafeCell;
use std::ffi::c_void;
use std::fmt::Write;
use std::sync::atomic::{AtomicU32, Ordering};
use std::sync::Mutex;

use josekit::jws;
use mariadb::log::{debug, error, info};
use mariadb::plugin::encryption::{Encryption, KeyError, KeyManager};
use mariadb::plugin::{
    register_plugin, Init, InitError, License, Maturity, PluginType, SysVarConstString, SysVarOpt,
};
use mariadb::service_sql::{ClientError, Connection, Rows};

const KEY_TABLE: &str = "mysql.clevis_keys";

/// Max length a key can be, used for table size and buffer checking
const KEY_MAX_BYTES: usize = 16;

/// String system variable to set server address
static TANG_SERVER: SysVarConstString = SysVarConstString::new();

register_plugin! {
    KeyMgtClevis,
    ptype: PluginType::MariaEncryption,
    name: "clevis_key_management",
    author: "Daniel Black & Trevor Gross",
    description: "Clevis key management plugin",
    license: License::Gpl,
    maturity: Maturity::Experimental,
    version: "0.1",
    init: KeyMgtClevis,
    encryption: false,
    variables: [
        SysVar {
            ident: TANG_SERVER,
            vtype: SysVarConstString,
            name: "tang_server",
            description: "the tang server to use for key exchange",
            options: [SysVarOpt::OptionalCliArg],
            default: "localhost"
        }
    ]
}

struct KeyMgtClevis;

impl Init for KeyMgtClevis {
    /// Create needed tables
    fn init() -> Result<(), InitError> {
        let mut conn = Connection::connect_local().map_err(|e| {
            error!("error with local connection: {e}");
            InitError
        })?;

        conn.execute(&format!(
            "CREATE TABLE IF NOT EXISTS {KEY_TABLE} (
                key_id INT UNSIGNED NOT NULL COMMENT 'MariaDB key_id',
                key_version INT UNSIGNED NOT NULL COMMENT 'MariaDB key_version',
                server VARCHAR(64) NOT NULL COMMENT 'Tang server that sourced this key',
                client_pub TINYTEXT NOT NULL COMMENT 'Public key generated by the client',
                PRIMARY KEY (key_id, key_version)
            ) ENGINE=InnoDB"
        ))
        .map_err(|e| {
            error!("error creating table {KEY_TABLE}: {e}");
            InitError
        })?;

        Ok(())
    }
}

impl KeyManager for KeyMgtClevis {
    fn get_latest_key_version(key_id: u32) -> Result<u32, KeyError> {
        let mut conn = key_connect()?;

        // Wrap everything in a transaction
        key_execute(&mut conn, "START TRANSACTION", key_id)?;

        let res = get_latest_key_version_innner(&mut conn, key_id);

        if res.is_ok() {
            key_execute(&mut conn, "COMMIT", key_id)?;
        } else {
            key_execute(&mut conn, "ROLLBACK", key_id)?;
        }

        res
    }

    fn get_key(key_id: u32, key_version: u32, dst: &mut [u8]) -> Result<(), KeyError> {
        let mut conn = key_connect()?;

        // Wrap everything in a transaction
        key_execute(&mut conn, "START TRANSACTION", key_id)?;

        let res = get_key_inner(&mut conn, key_id, key_version, dst);

        if res.is_ok() {
            key_execute(&mut conn, "COMMIT", key_id)?;
        } else {
            key_execute(&mut conn, "ROLLBACK", key_id)?;
        }

        res
    }

    fn key_length(_key_id: u32, _key_version: u32) -> Result<usize, KeyError> {
        Ok(KEY_MAX_BYTES)
    }
}

/// Locate a key if it exists, create one otherwise
fn get_latest_key_version_innner(conn: &mut Connection, key_id: u32) -> Result<u32, KeyError> {
    // Takes a row-level lock
    let mut q = format!(
        "SELECT key_version FROM {KEY_TABLE}
        WHERE key_id = {key_id}
        ORDER BY key_version DESC
        LIMIT 1
        FOR UPDATE"
    );

    {
        let mut rows = key_query(conn, &q, key_id)?;

        // Key exists, return the version
        if let Some(row) = rows.next() {
            let version_field = row.field(0);
            let version = version_field.as_int().unwrap().try_into().unwrap();
            assert!(rows.next().is_none(), "should only return one row");
            return Ok(version);
        }
    }

    // TODO: no key rotation yet so all key versions are 1 for now
    let key_version: u32 = 1;
    let new_key = tang_make_new_key()?;

    // reuse our string so we only allocate once
    q.clear();
    write!(
        q,
        r#"INSERT INTO {KEY_TABLE}
            (key_id, key_version, server, client_pub)
        VALUES
            ({key_id}, {key_version}, "{server_name}", "{new_key}")"#,
        server_name = TANG_SERVER.get()
    );

    key_execute(conn, &q, key_id)?;

    Ok(key_version)
}

fn get_key_inner(
    conn: &mut Connection,
    key_id: u32,
    key_version: u32,
    dst: &mut [u8],
) -> Result<(), KeyError> {
    let q = format!(
        "SELECT server, client_pub FROM {KEY_TABLE}
        WHERE key_id = {key_id}
        AND key_version = {key_version}"
    );

    let mut rows = key_query(conn, &q, key_id)?;

    let Some(row) = rows.next() else {
        panic!("expected a key row for kid {key_id} version {key_version}, but none was found")
    };
    assert!(
        rows.next().is_none(),
        "expected a single row for kid {key_id} version {key_version}"
    );

    let server = row.field(0).as_str().unwrap();
    let client_pub = row.field(1).as_str().unwrap();
    tang_retrieve_key(server, client_pub, dst)
}

/// Contact the Tang server to get a new private key
fn tang_make_new_key() -> Result<String, KeyError> {
    let client = clevis::TangClient::new(TANG_SERVER.get(), None);
    dbg!(client.fetch_keys().map_err(map_clevis_err));
    Ok("not yet implemented".into())
}

fn tang_retrieve_key(server: &str, client_pub: &str, dst: &mut [u8]) -> Result<(), KeyError> {
    let client = clevis::TangClient::new(server, None);

    Ok(())
}

/// Print a clevis client error, return a standard key error
fn map_clevis_err(e: clevis::Error) -> KeyError {
    error!("clevis client error: {e}");
    KeyError::Other
}

/// Connect to the local server. Return a KeyError on failure and print a message
fn key_connect() -> Result<Connection, KeyError> {
    Connection::connect_local().map_err(|e| {
        error!("error connecting: {e}");
        KeyError::Other
    })
}

/// Helper to execute a query, printing an error and returning KeyError if needed. Returns number
/// of updated rows.
fn key_execute(conn: &mut Connection, q: &str, key_id: u32) -> Result<u64, KeyError> {
    // FIXME: don't print actual values
    conn.execute(q).map_err(|e| {
        error!("execute key_id: {key_id}: SQL error: {e}. Query:\n{q}");
        KeyError::Other
    })
}

/// Helper to execute a query, printing an error, return the result
fn key_query<'conn>(
    conn: &'conn mut Connection,
    q: &str,
    key_id: u32,
) -> Result<Rows<'conn>, KeyError> {
    conn.query(q).map_err(|e| {
        error!("query key_id {key_id}: SQL error: {e}. Query:\n{q}");
        KeyError::Other
    })
}
